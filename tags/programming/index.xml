<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Hunting the Shmoo</title>
    <link>https://ahal.ca/tags/programming/</link>
    <description>Recent content in Programming on Hunting the Shmoo</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Andrew Halberstadt</copyright>
    <lastBuildDate>Sat, 24 May 2014 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ahal.ca/tags/programming/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>When would you use a Python mixin?</title>
      <link>https://ahal.ca/blog/2014/when-would-you-use-python-mixin/</link>
      <pubDate>Sat, 24 May 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ahal.ca/blog/2014/when-would-you-use-python-mixin/</guid>
      <description>&lt;p&gt;That&amp;rsquo;s not a rhetorical question. I&amp;rsquo;d like to know in which scenarios a mixin in python really is
the best option. I can&amp;rsquo;t seem to think of any, but maybe I&amp;rsquo;m not thinking outside the box enough.&lt;/p&gt;

&lt;p&gt;The basic idea of a mixin is to create a small re-usable class that can &amp;ldquo;plug-in&amp;rdquo; to other larger
classes. From the &lt;a href=&#34;http://en.wikipedia.org/wiki/Mixin&#34;&gt;wikipedia definition&lt;/a&gt;, a mixin is a way to compose classes together &lt;em&gt;without&lt;/em&gt;
using inheritance. The problem is unlike ruby, python mixins are a purely conceptual construct.
Python mixins &lt;em&gt;are&lt;/em&gt; inheritance (the only difference is that the class name usually contains
&amp;lsquo;Mixin&amp;rsquo;). It is up to the developer to remember this, and to manually avoid all of the common
pitfalls of multiple inheritance. This kind of defeats the whole purpose of the mixin in the first
place. What&amp;rsquo;s more is that most people use python mixins improperly.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Part 2: How to deal with IFFY requirements</title>
      <link>https://ahal.ca/blog/2014/part-2-how-deal-iffy-requirements/</link>
      <pubDate>Fri, 11 Apr 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ahal.ca/blog/2014/part-2-how-deal-iffy-requirements/</guid>
      <description>&lt;p&gt;My last post was basically a very long winded way of saying, &amp;ldquo;we have a problem&amp;rdquo;. It kind of did a
little dance around &amp;ldquo;why is there a problem&amp;rdquo; and &amp;ldquo;how do we fix it&amp;rdquo;, but I want to explore these two
questions in a bit more detail. Specifically, I want to return to the two case studies and explore
why our test harnesses don&amp;rsquo;t work and why mozharness does work even though both have IFFY (in flux
for years) requirements. Then I will explore how to use the lessons learned to improve our general
test harness design.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Part 1: Sharing code is not always a good thing</title>
      <link>https://ahal.ca/blog/2014/part-1-sharing-code-not-always-good-thing/</link>
      <pubDate>Fri, 21 Mar 2014 00:00:00 +0000</pubDate>
      
      <guid>https://ahal.ca/blog/2014/part-1-sharing-code-not-always-good-thing/</guid>
      <description>&lt;h3 id=&#34;dry-versus-wet&#34;&gt;Dry versus Wet&lt;/h3&gt;

&lt;p&gt;As programmers, we are taught early on that code duplication is bad and should be avoided at all
cost. It makes code less maintainable, reusable and readable. The &lt;a href=&#34;http://en.wikipedia.org/wiki/DRY_principle&#34;&gt;DRY principle&lt;/a&gt; is very basic
and fundamental to how most of us approach software design. If you aren&amp;rsquo;t familiar with the DRY
principle, please take a minute to read the wikipedia page on it. The counterpart of DRY, is WET
(write everything twice).  In general, I agree that DRY is good and WET is bad. But I think there
are a class of problems where the DRY approach can actually be harmful. For these types of problems,
I will make a claim that a WET approach can actually work better.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>